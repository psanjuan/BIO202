---
layout: topic
title: "Comparing multivariate data"
subtitle: "Symmetric methods for comparing two matrices"
author: Jes & Priscilla
output: html_document
---

**Assigned Reading:**

> Sections 10.5 (p. 597) and 11.5 (p. 696) from: Legendre, P. and L. Legendre. 2012. *Numerical Ecology*. Elsevier. [link](http://www.sciencedirect.com/science/bookseries/01678892/24)

*Skim the math to whatever degree you desire.*


```{r include = FALSE}
# This code block sets up the r session when the page is rendered to html
# include = FALSE means that it will not be included in the html document

# Write every code block to the html document 
knitr::opts_chunk$set(echo = TRUE)

# Write the results of every code block to the html document 
knitr::opts_chunk$set(eval = TRUE)

# Define the directory where images generated by knit will be saved
knitr::opts_chunk$set(fig.path = "images/06-C/")

# Set the web address where R will look for files from this repository
# Do not change this address
repo_url <- "https://raw.githubusercontent.com/fukamilab/BIO202/master/"
```

### Key Points

Use a symmetric methods when you don't have a hypothesis about the direction of effects between two matrices.

*Examples? Counter-examples?*



#### **Compare similarity/distance matrices**

*"These methods should not be used to test hypotheses about relationships between the original data tables."*

+ Use Chapter 7 to choose an appropriate distance measure for your data.

**Mantel test**

+ Box 10.2 on p. 600
+ Tests whether distances among objects are monotonically related to one another.
+ Steps:
    + Compute a Mantel statistic that is the scalar product of the (non-diagonal) values in (half of) the two distance matrices. (See Figure 10.19 on p. 599)
        + $z_M$ : raw distances
        + $r_M$ : use standardized distances and divide by $n(n-1)/2 - 1$ to get value between -1 and 1.
    + Test whether $z_M$ is significantly larger than expected by permuting the objects in one of the original data matrices used to compute one of the distance matrices. The generates a distribution of potential $z_M$ values under the null hypothesis.
+ Use Spearman (rank-based) correlation coefficient is non-linearity expected.
+ Distance matrices must be derived independently from one another on the same set of objects.
+ Many applications of Mantel test probably should be done using canonical analysis(e.g. distribution of organisms with respect to environment controlling for distance among sites)
+ Do not use Mantel test to make conclusions about correlations in the original data.

**Analysis of Similarity (ANOSIM)** and **PERMANOVA**

+ ANOSIM tests whether distances between groups are greater than within groups.
+ PERMANOVA tests whether distance differ between groups. This wasn't in the original reading for class, but you can find the method in [Anderson (2001)](http://dx.doi.org/10.1111/j.1442-9993.2001.01070.pp.x).
+ Both tests are sensitive to unbalanced designs and differences in dispersion (variance) within groups (e.g. not good when your groups have different variability). [Anderson and Walsh (2013)](http://dx.doi.org/10.1890/12-2010.1) conducted a simulation-based comparison of PERMANOVA and ANOSIM and found that PERMANOVA is more robust in general for ecological data, but still sensitive to heterogeneity of variance among groups. You should evaluate this assumption before using either test.
+ ANOSIM Steps:
    + Rank distances within the distance matrix, then compute the statistic $R = \frac{mean(rank_{between}) - mean(rank_{within})}{n(n-1)/4}$.
    + Test whether $R$ is larger than expected by permuting original objects.
+ PERMANOVA Steps:
    + Calculate an F ratio comparing $F \sim \frac{SS_{within groups}}{SS_across groups}$, where $SS$ means adding up the sum of the squares of the distances.
    + Test whether $F$ is smaller than expected by chance by permuting the original objects.
+ Groups should be defined *a priori* and not derived from distances.


#### **Compare two data tables**

+ Methods often used to jointly analyze variation two communities at the same set of sites.
+ Do not use to compare matrices that measure the same variables (e.g. before-after studies or control-impact experiments) because the analysis does not know that the variables are the same. (Use RDA or PCA instead.)
+ Both co-inertia and procrustes analyses can handle more variables than observations (e.g. more species than sites) as well as collinearity among variables.
+ Canonical correlation analysis (CCorA) is generally not recommended because it assumes multivariate normality of quantitative variables.

**Co-inertia analysis**

+ Creates an ordination based on two covariance between two data matrices and plots both matrices in the same ordination space along with their variables.
+ Steps:
    + Calculate cross-covariance matrix between variables in two matrices.
    + Calculate eigenvalues and eigenvectors of covariance matrix. Eigenvectors give the axes of the ordination.
    + Project the two matrices in the ordination space and use arrows to connect the two points measured on the same object.
    + Add arrows for each of the variables in the two matrices.
+ The total co-inertia is the sum of the squared covariances and the eigenvalues partition this among ordination axes.
+ Co-inertia analysis will preserve Euclidean or Mahalanois distances between objects depending on how projected matrices are scaled.
+ Can use data transformations prior to analysis (recommended for species occurrence data).
    + If so, do a principal coordinate analysis on the two distance martices and use the axes corresponding to positive eigenvalues as the data tables input into co-inertia analysis.
+ $RV$ coefficient is a statistic that measures correlation of two data matrices whose significance is tested by permutation.

**Procrustes analysis**

+ Creates a "compromise" ordination of two matrices measured on the same objects in order to visualize differences between two martices.
+ Algorithm rotates the matrices to minimize the sum of squared distances between corresponding objects.
+ Very similar to co-inertia analysis, but uses different matrices for plotting.
+ PROTEST method: compute symmetric orthogonal Procrustes statistic $m^2$ to measure similarity between two data matrices. 

**Multiple factor analysis**

+ Used to compare sets of variables- all variables within a set must be the same type.
+ Compute PCA on each variable set separately, then compute PCA of concatenated PC axes from all sets (that are first multiplied by a number to give equal weight to each set).
+ Project variable sets onto ordination plot to compare their correlation.



#### R packages and functions

`vegan`: functions for community composition analysis

+ `mantel()`
+ `protest()`
+ `anosim()`
+ `adonis()` for PERMANOVA
+ `betadisper()` for testing homogeneity of within-group variances

`ecodist`: functions for analysis of ecological dissimilarity

+ `mantel()`
+ `MRM()`

`ape`: functions fo phylogenetic analysis

+ `mantel.test()`

`ade4`: functions for multivariate analysis for ecologists

+ `mantel.rtest()`
+ `coinertia()` on two separate ordinations produced by `dudi.pca()` or `dudi.pco()`
+ `mfa()` on a `ktab` dataframe that divides variables into "blocks" produced by `ktab.data.frame()`



### Analysis Example

### Matrix comparisons

The following tests are used to test relationships between association matrices (i.e. distance or similarity matrices) not raw data!
+ Mantel test
+ Partial Mantel test
+ Multiple regression on distance matrices

``` {r, message = FALSE, warning = FALSE}
# Load packages
library(readr)
library(dplyr)
library(phyloseq)
library(vegan)
library(ade4)
library(ggplot2)
```


``` {r, message = FALSE, echo = FALSE, results = "hide"}
###########################################################################################
# Load data   

#####   CO1   #####
# Read CO1 otu table (except first column), read CO1 tax table 
otu.co <- as.matrix((read_csv("data/psanjuan/otu_mat.csv", col_names = TRUE)[,-1]))
tax.co <- as.matrix((read_csv("data/psanjuan/taxonomy.csv", col_names = TRUE)[,]))

# Add in rownames
otu.name <- as.matrix((read_csv("data/psanjuan/otu_mat.csv", col_names = TRUE)[,1]))
otu.co1  <- otu.co[,1]
rownames(otu.co) <- otu.name[,1]
  
# rownames(otu.co1) <- paste0("otu_", 1:nrow(otu.co1))        # paste "otu" followed by a number
tax.co1 <- tax.co[,-1]                                        # subset the "tax.co" matrix (basically all the data)
rownames(tax.co1) <- tax.co[,1]                               # name rows for "tax.co1" using "tax.co" first column as names

# Read file into phyloseq
OTU_co1 <- otu_table(otu.co, taxa_are_rows = TRUE)
TAX_co1 <- tax_table(tax.co1)

# Combining otu and tax tables
co1.data <- phyloseq(OTU_co1, TAX_co1)

# Read sample data file (contains all other metadata)
sample.co1 <- sample_data(data.frame(read_csv("data/psanjuan/sample_id.csv")))

# Naming the the first rows using the first column
row.names(sample.co1) = sample.co1$sample

# Merging otu/tax with sampledata (may include master mix and negative controls)
merged_co1 <- merge_phyloseq(co1.data, sample.co1)

# Remove master mix and negative controls from phyloseq object
rm.305 <- as.vector(data.frame(sample_data(merged_co1))$sample)
rm.305 <- (!(rm.305%in%c("1_305")))
rm.305[is.na(rm.305)] = FALSE
merged_co1 = prune_samples(rm.305, merged_co1)

#####   16S   #####
# Read 16S otu and tax tables, except first column because it is not numeric
otu.tab <- as.matrix((read_csv("data/psanjuan/OTU_tab_renamed.csv", col_names = TRUE)[,-1]))
tax.tab <- as.matrix((read_csv("data/psanjuan/TAX_reorder_otu_name.csv", col_names = TRUE)[,-1]))

# Add in rownames
rownames(otu.tab) <- paste0("OTU", 1:nrow(otu.tab))         # paste "otu" followed by a number
rownames(tax.tab) <- paste0("OTU", 1:nrow(tax.tab))         # paste "otu" followed by a number

# Read file into phyloseq
OTU <- otu_table(otu.tab, taxa_are_rows = TRUE)
TAX <- tax_table(tax.tab)

# Combining otu and tax tables
Bac.data <- phyloseq(OTU, TAX)

# Read sample data
sampledata  <- sample_data(data.frame(read_csv("data/psanjuan/samplesinfo.csv")))

# Name the first rows using the first column
row.names(sampledata) = sampledata$ID

# Merge otu/tax with sample data (includes master mix and negative controls)
merged_dataset <- merge_phyloseq(Bac.data, sampledata)

# Remove master mix and negative controls from phyloseq object
Real <- as.vector(data.frame(sample_data(merged_dataset))$Bird_species)
Real <- (!(Real%in%c("MM", "NEG", "RCRW")))
Real[is.na(Real)] = FALSE
merged_dataset_Real = prune_samples(Real, merged_dataset)

# Remove OTUs with bad BLAST matches
kingdom  <- as.vector(data.frame(tax_table(merged_dataset_Real))$kingdom)
tax.keep <- kingdom=="Bacteria"
tax.keep[is.na(tax.keep)] = FALSE
merged_dataset_Real <- prune_taxa(tax.keep,merged_dataset_Real)

# Remove class chloroplast (likely plant DNA not bacteria)
class <- as.vector(data.frame(tax_table(merged_dataset_Real))$class)
class <- (!(class%in%c("Chloroplast")))
class[is.na(class)] = FALSE
merged_dataset_Real = prune_taxa(class, merged_dataset_Real)

# Rarefaction of phyloseq object 
data.bird.rarefaction <- rarefy_even_depth(physeq = merged_dataset_Real, sample.size = 2000, rngseed = 7, replace = FALSE, trimOTUs = TRUE, verbose = TRUE)

###########################################################################################
# FIX DIMENSIONS   

# Using rarified data from microbial study
otu_16s <- otu_table(data.bird.rarefaction)
tax_16s <- tax_table(data.bird.rarefaction)       
sam_16s <- sample_data(data.bird.rarefaction)

# Nick's CO1 data - not rarified 
otu_co1 <- otu_table(merged_co1)
tax_co1 <- tax_table(merged_co1)                
sam_co1 <- sample_data(merged_co1)

# Subset microbial to CO1 data and CO1 to microbial data
sub_16s <- sam_16s[sam_16s$ID %in% sam_co1$sample]
sub_co1 <- sam_co1[sam_co1$sample %in% sam_16s$ID]

# Re-merged phyloseq objects with subsetted sample data
merged_16s <- merge_phyloseq(otu_16s, tax_16s, sub_16s)
merged_CO1 <- merge_phyloseq(otu_co1, tax_co1, sub_co1)

# Check dimensions to make sure samples match
dim(otu_table(merged_CO1))
dim(otu_table(merged_16s))
```

#### Mantel test

Compare two distance/similarity matrices that were obtained independently of each other

```{r}
# Transpose otu tables from both phyloseqs and convert to data frame
data_16s <- as.data.frame(t(otu_table(merged_16s)))
data_CO1 <- as.data.frame(t(otu_table(merged_CO1)))

# Calculate distance using Bray-Curtis
DM16s <- distance(merged_16s,"bray")
DMco1 <- distance(merged_CO1, "bray")

# Mantel test (using three different methods)
mantel(DMco1, DM16s, method = "pearson", permutations = 999)    
mantel(DMco1, DM16s, method = "spearman", permutations = 999)    
mantel(DMco1, DM16s, method = "kendall", permutations = 999)

# Plot the distances against each other (just to see)
plot(DMco1, DM16s, type = "p")


```

### Canonical Analysis

- Used to analyze relationships between two rectangular data tables
 
 The following tests can use raw data, not distance matrices (e.g. two community composition matrices)
 
 * Co-interia analysis
 * RV coefficient
 * Procrustes 


#### Co-inertia analysis

* Search for common structures between two data sets describing the same objects by projecting them onto a common multivariate space
* Uses two responses containing different variables

```{r}
dudi.16s <- dudi.pca(data_16s, scale=T, scan=F, nf=5)
dudi.c01 <- dudi.pca(data_CO1, scale=T, scan=F, nf=5)
co.in.data <- coinertia(dudi.16s, dudi.c01, scan=F, nf=5)
summary(co.in.data)
randtest(co.in.data, nrepet = 999)
plot(co.in.data)
```


#### RV coefficient

* multivariate generalization of Pearson correlation coefficient 
* tests whether two matrices are linked
* value is given through co-inertia analysis but can also try 

`RV.rtest(data_16s, data_CO1)`


#### Procrustes

* measure of concordance, similarity, between two data matrices 
* more powerful than Mantel test

``` {r, warning = FALSE, results = "hide"}
# Only run this once and then re-load
#procrust.data <- protest(data_CO1, data_16s)

# Save and reload the Procrustes analysis results
#save(procrust.data, file = "data/psanjuan/procrust_data.RData")
load("data/psanjuan/procrust_data.RData")

summary(procrust.data)
```

``` {r, warning = FALSE}
plot(procrust.data)
```


### Discussion Questions

* What are some examples of datasets that are compatible for these tests? Any rule of thumb to easily identify an appropriate test (beside trying all of them)?
* Any experience with this type of analyses?
* "Which method should be used for symmetric analysis of two data sets?"



### Further Readings

For information on three-table methods see:

+ Dray, S. P. et al. 2014. Combining the fourth-corner and RLQ methods for assessing trait responses to environmental variation. *Ecology* **95**: 14-21. [DOI: 10.1890/13-0196.1](http://dx.doi.org/10.1890/13-0196.1). and Supplement 1: A tutorial to perform fourth-corner and RLQ analyses in R. [Ecological Archives E095-002-S1](http://esapubs.org/archive/ecol/E095/002/suppl-1.php)
